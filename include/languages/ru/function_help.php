<?php

return array
(
	// round
	'<h3>Описание</h3>
		<p><code>round(num, precision)</code></p>
		<p>Возвращает округленное значение num используя precision (количество знаков после запятой). precision может быть отрицательным, или нулем (по умолчанию).</p>
	<p><h3>Параметры</h3>
		<dl>
			<dt>num</dt><dd>Значение, которое надо округлить. Если его нет, то возвращается 0.</dd>
			<dt>precision</dt><dd>Количество знаков после запятой. Если его нет, то используется 0.
				<p>Если precision положительный, num округляется до precision знаков после запятой.</p>
				<p>Если precision отрицательный, num округляется до -precision знаков перед запятой, другими словами до ближайшего значения (10 ^ (-precision)). То есть, для -1 num округляется до десятков, для -2 до сотен, итд.</p></dd>
		</dl>
	<p><h3>Примеры</h3><p>
		<code>round(1.4)</code> это 1<br> 
		<code>round(5.5)</code> это 6<br> 
		<code>round(3.1415926, 2)</code> это 3.14<br> 
		<code>round(587, -2)</code> это 600 </p>',

	// floor
	'<h3>Описание</h3>
		<p><code>floor(num)</code></p>
		<p>Возвращает ближайшее меньшее целое для num.</p>
	<h3>Параметры</h3>
		<dl>
			<dt>num</dt><dd>Значение, которое надо округлить вниз. Если его нет, то возвращается 0.</dd>
		</dl>
	<h3>Примеры</h3>
		<p><code>floor(1.4)</code> это 1<br> 
		<code>floor(5.5)</code> это 5<br> 
		<code>floor(999.99999)</code> это 999<br>',

	// ceil
	'<h3>Описание</h3>
		<p><code>ceil(num)</code></p>
		<p>Возвращает ближайшее большее целое для num.</p>
	<h3>Параметры</h3>
		<dl>
			<dt>num</dt><dd>Значение, которое надо округлить вверх. Если его нет, то возвращается 0.</dd>
		</dl>
	<h3>Примеры</h3>
		<p><code>ceil(1.4)</code> это 2<br> 
		<code>ceil(5.5)</code> это 6<br> 
		<code>floor(0.00001)</code> это 1<br>',

	// log
	'<h3>Описание</h3>
		<p><code>log(num, base)</code></p>
		<p>Если параметр base указан, log() возвращает логарифм num по основанию base log<sub>base</sub>(num). Если не указан, то возвращается натуральный логарифм от num.</p>
	<h3>Параметры</h3>
		<dl>
			<dt>num</dt><dd>Значение для котрого надо вычислить логарифм.</dd>
			<dt>base</dt><dd>Основание логарифма. Если отсутствует, то используется \'e\').</dd>
		</dl>
	<h3>Примеры</h3>
		<p><code>log(1)</code> это '.log(1).'<br> 
		<code>log(4,2)</code> это '.log(4,2).'<br> 
		<code>log(1000,10)</code> это '.log(1000,10).'<br> 
		<code>log(0)</code> это '.EV_MIN_VALUE.' - это число представляет собой минимальное значение для вычислителя формул. Оно выполняет роль отрицательной бесконечности.<br>',

	// min
	'<h3>Описание</h3>
		<p><code>min(value1, value2, ...)</code></p>
		<p>Возвращает наименьшее из value1, value2, value3, etc...</p>
	<h3>Параметры</h3>
		<dl>
			<dt>valueN</dt><dd>Одно из значений из которых надо выбрать наименьшее.</dd>
		</dl>
	<h3>Примеры</h3>
		<p><code>min(1)</code> это 1<br> 
		<code>min(7.01, 6.99)</code> это 6.99<br> 
		<code>min(1,2,3,4,5,6)</code> это 1<br> 
		<code>max(min(value(), 1), 0)</code> - гарантирует, что значение будет лежать в границах от 0 до 1</p>',

	// max
	'<h3>Описание</h3>
		<p><code>max(value1, value2, ...)</code></p>
		<p>Возвращает наибольшее из value1, value2, value3, etc...</p>
	<h3>Параметры</h3>
		<dl>
			<dt>valueN</dt><dd>Одно из значений из которых надо выбрать наибольшее.</dd>
		</dl>
	<h3>Примеры</h3>
		<p><code>max(1)</code> это 1<br> 
		<code>max(7.01, 6.99)</code> это 7.01<br> 
		<code>max(1,2,3,4,5,6)</code> это 6<br> 
		<code>max(min(value(), 1), 0)</code> - гарантирует, что значение будет лежать в границах от 0 до 1</p>',

	// counter
	'<h3>Описание</h3>
		<p><code>counter(type, number)</code></p>
		<p>Возвращает значение счетчика для текущего игрока-игры. Счетчик это объект созданный в системе подсчета баллов в секции Счетчики.</p>
	<h3>Параметры</h3>
		<dl>
			<dt>type</dt><dd>Определяет какое значение счетчика будет взято.<br>0 - финальное значение счетчика для всех сыгранных игр.<br>1 - текущее значение счетчика посчитанное только для игр сыгранных до текущей включительно.</dd>
			<dt>number</dt><dd>Номер счетчика в том порядке в котором счетчики видны в редакторе. Нумерация начинается с 0.</dd>
		</dl>
	<h3>Примеры</h3>
		<p>Предположим, мы создали два счетчика для нашей системы подсчета баллов. Первый (номер 0) считает количество игр, где игрок был убит в первую ночь и был при этом красным. Второй (номер 1) считает количество игр сыгранных игроком в красном цвете.</p>
		<p>Тогда:<br>
		<code>counter(0,1)</code> возвращает общее количество игр сыгранных красным.<br> 
		<code>counter(1,1)</code> возвращает количество игр сыгранных красным до текущей игры включительно.<br> 
		<code>counter(1,1)-matter(8)</code> возвращает количество игр сыгранных красным до текущей игры, исключая текущую игру. См функцию matter.<br> 
		<code>counter(0,0)</code> возвращает общее количество красных игр для игрока.<br>
		<code>counter(1,0) * 100 / counter(1,1)</code> возвращает финальны процент отстрелов игрока в красном цвете.</p>',

	// bonus
	'<h3>Описание</h3>
		<p><code>bonus()</code></p>
		<p>Возвращает допы выставленные судьей игроку в игре.</p>
	<h3>Примеры</h3>
		<code>bonus()/2</code> допы выставленные судьёй деленные на два.<br> 
		<code>bonus()*difficulty()</code> допы выставленные судьёй с весом трудности игры. См функцию difficulty.</p',

	// role
	'<h3>Описание</h3>
		<p><code>role()</code></p>
		<p>Возвращает роль игрока в игре. Значения:<br>
			<ol start="0">
				<li>простой красный</li>
				<li>шериф</li>
				<li>мафия</li>
				<li>дон</li>
			</ol>
		</p>
	<h3>Примеры</h3>
		<code>role() < 2 ? bonus() : 0</code> для красных игоков допы, для черных - 0. См функцию bonus.<br> 
		<code>role() == 1 || role() == 3 ? 1 : difficulty() * 2</code> Для спец-ролей 2, для остальных нечто от 0 до 2 в зависимости от трудности игры. См функцию difficulty.</p',

	// difficulty
	'<h3>Описание</h3>
		<p><code>difficulty()</code></p>
		<p>Возвращает коэффициент трудности игры. Это значение от 0 до 1. Отношение игр выигранных противоположной командой к общему количеству игр. Если игрок красный, то это количество черных побед, деленное на общее количество игр. А если черный, то наоборот, количество красных побед на общее количество игр.</p>
	<h3>Примеры</h3>
		<code>difficulty() * 2</code> значение от 0 до 2 в зависимости от трудности игры.</p',
		
	// matter
	'<h3>Описание</h3>
		<p><code>matter(type)</code></p>
		<p>Возвращает 0, или 1 в зависимости от того, случилось ли с игроком определенное событие в игре.</p>
	<h3>Параметры</h3>
		<dl>
			<dt>type</dt><dd>Код события. Коды:<ol start="0">
				<li>Играл в игре</li>
				<li>Выиграл игру</li>
				<li>Проиграл игру</li>
				<li>Все игроки убитые днем были из противоположной команды</li>
				<li>Все игроки убитые днем были из своей команды</li>
				<li>Получил лучшего игрока от судьи</li>
				<li>Получил лучший ход от судьи</li>
				<li>Выжил в игре</li>
				<li>Был убит в первую ночь</li>
				<li>Был убит ночью</li>
				<li>Оставил троих в ЛХ</li>
				<li>Оставил двоих в ЛХ</li>
				<li>Получил четыре замечания и удалился</li>
				<li>Был удален</li>
				<li>Сдался</li>
				<li>Голосовал только против мафии (участвуя в 3+ голосований)</li>
				<li>Голосовал только против мирных (участвуя в 3+ голосований)</li>
				<li>Шериф был убит на следующую ночь после того, как его нашел дон</li>
				<li>Шериф был найден доном в первую ночь</li>
				<li>Шериф был убит в первую ночьё</li>
				<li>Шериф сделал три черные проверки подряд</li>
				<li>Все проверки шерифа были красными</li>
				<li>Получил допы</li>
				<li>Оставил одного в ЛХ</li>
				<li>Получил худший ход от судьи (aka снят автодоп)</li>
				<li>Сделал ППК</li>
			</ol></dd>
		</dl>
	<h3>Примеры</h3>
		<p><code>matter(8) && matter(2) ? 0.2 : 0</code> 0.2 если игрок был убит первой ночью и команда проиграла.<br> 
		<code>matter(8) && !matter(23) && !matter(10) && !matter(11) ? -0.4 : 0</code> -0.4 если игрок был убит первой ночью и не оставил ни одного черного в ЛХ.<br> 
		<code>matter(12) || matter(13) ? -0.5 : 0</code> -0.5 если игрок получил 4 замечания, или был выкинут из игры судьей.</p>',
);

?>